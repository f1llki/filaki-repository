#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

class PrimGraph {
private:
    int V; // Количество вершин
    vector<vector<pair<int, int>>> adj; // Список смежности

public:
    PrimGraph(int vertices) : V(vertices) {
        adj.resize(V);
    }

    void addEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight}); // Неориентированный граф
    }

    // Алгоритм Прима для построения минимального остовного дерева
    int primMST() {
        vector<bool> inMST(V, false); // Отслеживание вершин в MST
        vector<int> key(V, INT_MAX);   // Ключи для выбора минимального ребра
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        int totalWeight = 0; // Общий вес MST
        
        // Начинаем с вершины 0
        key[0] = 0;
        pq.push({0, 0}); // (ключ, вершина)
        
        while (!pq.empty()) {
            int u = pq.top().second;
            int weight = pq.top().first;
            pq.pop();
            
            // Если вершина уже в MST, пропускаем
            if (inMST[u]) continue;
            
            // Добавляем вершину в MST
            inMST[u] = true;
            totalWeight += weight; // Добавляем вес ребра
            
            // Обновляем ключи соседей
            for (auto &edge : adj[u]) {
                int v = edge.first;
                int w = edge.second;
                
                // Если вершина не в MST и найден более легкий путь
                if (!inMST[v] && w < key[v]) {
                    key[v] = w;
                    pq.push({w, v}); // Добавляем в очередь
                }
            }
        }
        
        return totalWeight;
    }
};

int main() {
    PrimGraph g(4);
    
    // Строим граф
    g.addEdge(0, 1, 10);
    g.addEdge(0, 2, 6);
    g.addEdge(0, 3, 5);
    g.addEdge(1, 3, 15);
    g.addEdge(2, 3, 4);
    
    int mstWeight = g.primMST();
    cout << "Вес минимального остовного дерева: " << mstWeight << endl;
    
    return 0;
}
